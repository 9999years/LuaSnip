*luasnip.txt*	For Neovim 0.5			       Last change: 2021 April 8
            __                       ____                          ~
           /\ \                     /\  _`\           __           ~
           \ \ \      __  __     __ \ \,\L\_\    ___ /\_\  _____   ~
            \ \ \  __/\ \/\ \  /'__`\\/_\__ \  /' _ `\/\ \/\ '__`\ ~
             \ \ \L\ \ \ \_\ \/\ \L\.\_/\ \L\ \/\ \/\ \ \ \ \ \L\ \~
              \ \____/\ \____/\ \__/.\_\ `\____\ \_\ \_\ \_\ \ ,__/~
               \/___/  \/___/  \/__/\/_/\/_____/\/_/\/_/\/_/\ \ \/ ~
                                                             \ \_\ ~
                                                              \/_/ ~

================================================================================
CONTENTS                                                        *luasnip-contents*

  Intro .......................................................... |luasnip-intro|
  Snippets ........................................................... |luasnip-s|
  TextNode ........................................................... |luasnip-t|
  InsertNode ......................................................... |luasnip-i|
  FunctionNode ....................................................... |luasnip-f|
  SnippetNode ....................................................... |luasnip-sn|
  ChoiceNode ......................................................... |luasnip-c|
  DynamicNode ........................................................ |luasnip-d|

================================================================================

INTRO								   *luasnip-intro*

Luasnip is a snippet-engine written entirely in lua. It has some great features
like inserting text (|luasnip-f|) or nodes (|luasnip-d|) based on user input,
parsing lsp-syntax and switching nodes (|luasnip-c|).

All code-snippets in this help assume that >

    local ls = require'luasnip'
    local s = ls.s
    local sn = ls.sn
    local t = ls.t
    local i = ls.i
    local f = ls.f
    local c = ls.c
    local d = ls.d
<
================================================================================

SNIPPETS							       *luasnip-s*

The most direct way to define snippets is `s`: 
>
    s({trig='trigger'}, {
    	i(0)
    })
< 
(This Snippet is useless beyond being a minimal example)

`s` accepts, as the first argument, a table with the following possible
entries:

    `trig`	String	    Trigger, Plain text by default	Required
    `name`	String	    Name, used by other plugins		Optional, `trig`
    `dscr`	String	    Description, used by other		Optional, `trig`
			    plugins
    `wordTrig`	Boolean	    If true, the snippet is only	Optional, `false`
			    expanded if the word (`[%w_]+`)
			    before the cursor matches the
			    trigger entirely
    `regTrig`	Boolean	    If true, `trig` is interpreted as	Optional, `false`
			    a lua-pattern

The second argument to `s` is a table containing all nodes that belong to the
snippet, at least one of which has to be an `i(0)` node.

Snippets that should be loaded for all files must be put into the
`ls.snippets.all`-table, those only for a specific filetypes `ft` belong into
`ls.snippets.ft`.

================================================================================

TEXTNODE							       *luasnip-t*

The most simple kind of node; just text.
>
    s({trig='trigger'}, {
    	t({"Wow! Text!"}),
    	i(0)
    })
<
This Snippet expands to
>
    Wow! Text!|
<
, where `|` is the cursor.
Multiline-strings can be defined by creating multiple entries inside the table:
>
    s({trig='trigger'}, {
    	t({"Wow! Text!", "And another line."}),
    	i(0)
    })
<
================================================================================

INSERTNODE							       *luasnip-i*

These Nodes can be jumped to- and from, the functionality is best demonstrated
with an example:
>
    s({trig='trigger'}, {
    	t({"After jumping forward once cursor is here ->"}), i(2),
    	t({"", "After expanding the cursor is here ->"}), i(1),
    	t({"", "And after jumping once more the snippet is exited there ->"}), i(0),
    })
<
It's possible to have easy-to-overwrite text inside an InsertNode initially:
>
    s({trig='trigger'}, {
    	i(1, {"This text is SELECTed after expanding the snippet."}), i(0),
    })
<
This initial text is defined the same way as textNodes, eg. can be multiline.

================================================================================
vim:tw=80:ts=8:noet:ft=help:
