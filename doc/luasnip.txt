*luasnip.txt*       For Neovim 0.5                       Last change: 2021 April 8
            __                       ____                          ~
           /\ \                     /\  _`\           __           ~
           \ \ \      __  __     __ \ \,\L\_\    ___ /\_\  _____   ~
            \ \ \  __/\ \/\ \  /'__`\\/_\__ \  /' _ `\/\ \/\ '__`\ ~
             \ \ \L\ \ \ \_\ \/\ \L\.\_/\ \L\ \/\ \/\ \ \ \ \ \L\ \~
              \ \____/\ \____/\ \__/.\_\ `\____\ \_\ \_\ \_\ \ ,__/~
               \/___/  \/___/  \/__/\/_/\/_____/\/_/\/_/\/_/\ \ \/ ~
                                                             \ \_\ ~
                                                              \/_/ ~

================================================================================
CONTENTS                                                        *luasnip-contents*

	Intro ........................................................ |luasnip-intro|
	Snippets ......................................................... |luasnip-s|
	TextNode ......................................................... |luasnip-t|
	InsertNode ....................................................... |luasnip-i|
	FunctionNode ..................................................... |luasnip-f|
	ChoiceNode ....................................................... |luasnip-c|
	SnippetNode ..................................................... |luasnip-sn|
	DynamicNode ...................................................... |luasnip-d|

================================================================================

INTRO                                                              *luasnip-intro*

Luasnip is a snippet-engine written entirely in lua. It has some great features
like inserting text (|luasnip-f|) or nodes (|luasnip-d|) based on user input,
parsing lsp-syntax and switching nodes (|luasnip-c|).

All code-snippets in this help assume that >

	local ls = require'luasnip'
	local s = ls.s
	local sn = ls.sn
	local t = ls.t
	local i = ls.i
	local f = ls.f
	local c = ls.c
	local d = ls.d
<
================================================================================

SNIPPETS                                                               *luasnip-s*

The most direct way to define snippets is `s`: 
>
	s({trig='trigger'}, {
	i(0)
	})

(This Snippet is useless beyond being a minimal example)

`s` accepts, as the first argument, a table with the following possible
entries:

	`trig`        string      Trigger, Plain text by default    Required
	`name`        String      Name, used by other plugins       Optional, `trig`
	`dscr`        String      Description, used by other        Optional, `trig`
	                        plugins
	`wordTrig`    Boolean     If true, the snippet is only      Optional, `false`
	                        expanded if the word (`[%w_]+`)
	                        before the cursor matches the
	                        trigger entirely
	`regTrig`    Boolean      If true, `trig` is interpreted      Optional, `false`
                            as a lua-pattern

The second argument to `s` is a table containing all nodes that belong to the
snippet, at least one of which has to be an `i(0)` node.

Snippets contain some interesting tables, eg. `snippet.env` contains variables
used in the LSP-protocol like `TM_CURRENT_LINE` or `TM_FILENAME` or
`snippet.captures`, where capture-groups of regex-triggers are stored. These
tables are primarily useful in dynamic/functionNodes, where the snippet is
passed to the generating function.

Snippets that should be loaded for all files must be put into the
`ls.snippets.all`-table, those only for a specific filetype `ft` belong in
`ls.snippets.ft`.

================================================================================

TEXTNODE                                                               *luasnip-t*

The most simple kind of node; just text.
>
	s({trig='trigger'}, {
		t({"Wow! Text!"}),
		i(0)
	})
<
This Snippet expands to
>
    Wow! Text!|
<
, where `|` is the cursor.
Multiline-strings can be defined by creating multiple entries inside the table:
>
	s({trig='trigger'}, {
		t({"Wow! Text!", "And another line."}),
		i(0)
	})
<
================================================================================

INSERTNODE                                                             *luasnip-i*

These Nodes can be jumped to- and from, the functionality is best demonstrated
with an example:
>
	s({trig='trigger'}, {
		t({"After jumping forward once cursor is here ->"}), i(2),
		t({"", "After expanding the cursor is here ->"}), i(1),
		t({"", "After jumping once more the snippet is exited there ->"}), i(0),
	})
<
It's possible to have easy-to-overwrite text inside an InsertNode initially:
>
	s({trig='trigger'}, {
		i(1, {"This text is SELECTed after expanding the snippet."}),
		i(0),
	})
<
This initial text is defined the same way as textNodes, eg. can be multiline.

================================================================================

FUNCTIONNODE                                                           *luasnip-f*

Function Nodes insert text based on the content of other nodes using a
user-defined function: 
>
	s({trig = "trig"}, {
		i(1)
		f(function(args, user_arg_1) return {args[1][1] .. user_arg_1} end,
			{1},
			"Will be appended to text from i(0)"),
		i(0)
	})
<
The first parameter of `f` is the function. Its parameters are
	1.: a table of text and the surrounding snippet (ie.
	`{{line1}, {line1, line2}, snippet}`).
	The Snippet is included here, as it allows access to anything that could be
	useful in functionNodes (ie.  `snippet.env` or `snippet.captures`, which
	contains capture groups of regex-triggered snippets).

	2.: Any parameters passed to `f` behind the second (included to more easily
	reuse functions, ie. ternary if based on text in an insertNode).

The second parameter is a table of indizes of jumpable nodes whose text is
passed to the function. The table may be empty, in this case the function is
evaluated once upon snippet-expansion.

Examples:
	Use captures from the regex-trigger using a functionNode:
>
	s({trig = "b(%d)", regTrig = true, wordTrig = true}, {
		f(function(args) return
			{"Captured Text: " .. args[1].captures[1] .. "."} end, {}),
		i(0)
	})
<
================================================================================

CHOICENODE                                                             *luasnip-c*

ChoiceNodes allow choosing between multiple nodes.
>
	s({trig = "trig"}, {
		c(1, {
			t({"Ugh boring, a text node"}),
			i(nil, {"At least I can edit something now..."}),
			f(function(args) return {"Still only counts as text!!"} end, {})
		}), i(0)
	})

`c()` expects as it first arg, as with any jumpable node, its position in the
jumplist, and as its second a table with nodes, the choices.

Jumpable nodes that normally expect an index as their first parameter don't
need one inside a choiceNode; their index is the same as the choiceNodes'.

================================================================================

SNIPPETNODE                                                           *luasnip-sn*

SnippetNodes directly insert their contents into the surrounding snippet.
This is useful for choiceNodes, which only accept one child, or dynamicNodes,
where nodes are created at runtime and inserted as a snippetNode.

Syntax is similar to snippets, however, where snippets require a table
specifying when to expand, snippetNodes, similar to insertNodes, expect a
number, as they too are jumpable:
>
	s({trig = "trig"}, {
		sn(1, {
			t({"basically just text "}),
			i(1, {"And an insertNode."})
		}),
		i(0)
	})
<

Note that snippetNodes don't expect an `i(0)`.

================================================================================

DYNAMICNODE                                                            *luasnip-d* 

Very similar to functionNode: returns a snippetNode instead of just text,
which makes them very powerful.

Parameters:
	1. position (just like all jumpable nodes)
	2. function: Similar to functionNodes' function, first parameter is the
		`table of text` from nodes the dynamicNode depends on, the second,
		unlike functionNode, is a user-defined table, `old_state`.
		This table can contain anything, its main usage is to preserve
		information from the previous snippetNode:
		If the dynamicNode depends on another node it may be reconstructed,
		which means all user input to the dynamicNode is lost. Using
		old_state, the user may pass eg. insertNodes and then get their text
		upon reconstruction to initialize the new nodes with.
		The old_state-table must be stored inside the snippetNode returned by
		the function.
		All parameters following the second are user defined.
	3.  Nodes the dynamicNode depends on: if any of these trigger an update,
		the dynamicNodes function will be executed and the result inserted at
		the nodes place.
	4f. The fourth and following parameters are user defined, anything passed
		here will also be passed to the function (arg 2) following its second
		parameter (easy to reuse similar functions with small changes).
>
	local function lines(args, old_state, initial_text)
		local nodes = {}
		if not old_state then old_state = {} end

		-- count is nil for invalid input.
		local count = tonumber(args[1][1])
		-- Make sure there's a number in args[1].
		if count then
			for j=1, count do
				local iNode
				if old_state and old_state[j] then
					-- old_text is used internally to determine whether
					-- dependents should be updated. It is updated whenever the
					-- node is left, but remains valid when the node is no
					-- longer 'rendered', whereas get_text() grabs the text
					-- directly form the node.
					iNode = i(j, old_state[j].old_text)
				else
				  iNode = i(j, initial_text)
				end
				nodes[2*j-1] = iNode

				-- linebreak
				nodes[2*j] = t({"",""})
				-- Store insertNode in old_state, potentially overwriting older
				-- nodes.
				old_state[j] = iNode
			end
		else
			nodes[1] = t({"Enter a number!"})
		end
		
		local snip = sn(nil, nodes)
		snip.old_state = old_state
		return snip
	end

	...

	s({trig="trig"}, {
		i(1, {"1"}),
		-- pos, function, nodes, user_arg1
		d(2, lines, {1}, {"Sample Text"})
		i(0)
	})
<
This snippet would start out as "1\nSample Text" and, upon changing the 1 to
eg. 3, it would change to "3\nSample Text\nSample Text\nSample Text". Text
that was inserted into any of the dynamicNodes insertNodes is kept when
changing to a bigger number.

================================================================================

vim:tw=78:ts=4:ft=help:norl:
